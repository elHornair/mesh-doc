<!DOCTYPE html>
<html>
<head>
    <title>Dokumentation C-Mesh</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="css/master.css" />
    <script type="text/javascript" src="js/main.js"></script>
</head>

<body>

<div class="dummy"></div>
<div class="frontpage">
    <h1>C-Mesh</h1>
    <h2>Routing-Simulation in C</h2>
    <p>Seminararbeit im Rahmen von "Concurrent Programming in C" Im Studiengang Informatik an der ZHAW
       von Alain Horner - Frühjahr 2013</p>
</div>

<h1>Inhaltsverzeichnis</h1>
<ol id="toc">
</ol>

<div id="content">

    <div class="chapter">
        <h1>Projektbeschreibung</h1>

        <h2>Ziel der Arbeit</h2>
        <p>
            Es soll eine Applikation entwickelt werden, die das Routing von Netzwerkpaketen simuliert. Die Applikation
            muss in C geschrieben werden.
        </p>

        <h2>Aufgabenstellung</h2>
        <p>
            Das Aufgabe wurde gemeinsam in der Klasse spezifiziert
            <span class="footnote source">
                Systemsoftware Mesh Projekt<span class="additional">, Abgerufen am 01.05.2013 von
                http://edu.panter.ch/Mesh</span></span>. Die Netzwerkpakete sollen folgendes Format haben:
        </p>
        <table>
            <caption>Format Netzwerkpakete</caption>
            <tr>
                <th>Grösse</th>
                <th>Datum</th>
            </tr>
            <tr>
                <td>2 Bytes</td>
                <td>Paket-ID</td>
            </tr>
            <tr>
                <td>1 Byte</td>
                <td>Ziel (1) oder Quelle (0)</td>
            </tr>
            <tr>
                <td>1 Byte</td>
                <td>Paket-Typ ('C', 'O' oder 'N')</td>
            </tr>
            <tr>
                <td>128 Bytes</td>
                <td>Inhalt</td>
            </tr>
        </table>
        <p>
            Der Paket-Typ hat dabei folgende Bedeutung:
        </p>
        <ul>
            <li>C: Inhaltspaket. Der Inhaltsteil enthält dann die zu übermittelnde Nachricht. Ein Mesh Switch, leitet
                nur das erste Paket mit einer Paket-ID weiter, die folgenden Pakete mit der gleichen Paket-ID wirft er
                weg.</li>
            <li>O: OK-Paket. Dieses signalisiert, dass das Paket angekommen ist. Ein Paket, das sein Ziel erreicht, wird
                mit einem O-Paket beantwortet. Die Paket-ID ist dabei identisch mit jener des zu bestätigenden C-Pakets</li>
            <li>N: Verbindungspaket. Dieses Paket weist einen Mesh Switch an, sich mit einem neuen Nachbarn zu verbinden.
                Der Inhalt des Pakets enthält dann 4 Bytes mit der IP Adresse und 2 Bytes mit dem TCP Port des
                entsprechenden Nachbarn.</li>
        </ul>
        <p>
            Das Executable soll folgendes Interface aufweisen: <span class="code">mesh portnum [-q|-z]</span>. Die Parameter bedeuten dabei
            Folgendes:
        </p>
        <ul>
            <li><span class="code">portnum</span> ist eine TCP-Portnummer. Default ist 3333</li>
            <li>Es kann entweder <span class="code">-q</span>, <span class="code">-z</span>, oder nichts als zusätzliches Argument angegeben werden</li>
            <li>Wenn als Argument <span class="code">-q</span> angegeben wird, dann ist der Mesh Router die Quelle</li>
            <li>Wenn als Argument <span class="code">-z</span> angegeben wird, dann ist der Mesh Router das Ziel</li>
        </ul>

        <h2>Erwartete Resultate</h2>
        <ul>
            <li>
                Es soll eine Anwedung entwickelt werden, die folgende Anforderungen erfüllt:
                <ul>
                    <li>Kein global Lock</li>
                    <li>Verwendung von Pthreads</li>
                    <li>Muss vorgegebenes Testprogramm bestehen</li>
                    <li>Soll im <i>tgz</i>-Format abgegeben werden</li>
                    <li>Muss mit <i>make</i> kompiliert werden können</li>
                    <li>Format der Pakete muss der Spezifikation entsprechen</li>
                    <li>Interface des Executables muss der Spezifikation entsprechen</li>
                </ul>
            </li>
            <li>Dokumentation, welche das Konzept des Prototyps sowie Probleme, die aufgetaucht sind, beschreibt.</li>
        </ul>

        <h2>Einschränkungen</h2>
        <p>
            Placeholder
        </p>
    </div>

    <div class="chapter">
        <h1>Projektplanung</h1>

        <h2>Zeitlicher Rahmen</h2>
        <p>
            Der Kurs wird mit zwei ECTS-Punkten honoriert, was einem Aufwand von 50-60 Stunden gleichkommt.
            Davon werden zehn Stunden für Kickoff-Meeting, Koordination und Präsentation abgezogen.
            Somit verbleiben 40-50 Stunden für die Bearbeitung des Themas. Die zur Verfügung stehende Zeit wird wie folgt
            für die Teilarbeiten eingeplant:
        </p>
        <ul>
            <li>Recherchen, Einlesen in das Thema: 5 Stunden</li>
            <li>Entwicklung des C-Programms: 35 Stunden</li>
            <li>Dokumentation: 10 Stunden</li>
        </ul>

        <h2>Meilensteine</h2>
        <p>
            Folgende Termine sind vorgegeben:
        </p>
        <ul>
            <li>25. März 2013: Kickoff-Meeting und Festlegung des Themas</li>
            <li>14. Juni 2013: Abgabe der Seminararbeit</li>
            <li>21. Juni 2013: Präsentation der Seminararbeit</li>
        </ul>
    </div>

    <div class="chapter">
        <h1>Konzept der Umsetzung</h1>
        <p>
            In diesem Kapitel werden die Funktionsweise der entwickelten Anwendung und die dahinterstehenden Konzepte
            erläutert.
        </p>

        <h2>Funktionsweise der Knoten</h2>
        <p>
            Das implementierte Netz<span class="footnote">Englisch: Mesh</span> besteht aus beliebig vielen Knoten. In
            der Aufgabenstellung werden diese Mesh-Switches genannt. Ein einzelner Knoten wird mit Hilfe des bereits
            definierten Interfaces<span class="footnote">Siehe Aufgabenstellung</span> erstellt. Beim Starten eines
            Knotens wird dessen Art (Startknoten, Zielknoten oder Zwischenknoten) gespeichert. Der entsprechende
            TCP-Port wird geöffnet und der Knoten wartet auf ein ankommendes Paket. Dies alles geschieht im Haupt-Thread
            des Knotens.
        </p>
        <p>
            Sobald ein Paket über den geöffneten TCP-Port ankommt, erstellt der Knoten einen neuen Worker-Thread und
            übergibt ihm das Paket zur weiteren Bearbeitung. Für den Haupt-Thread ist die Arbeit bezüglich dieses Pakets
            somit erledigt und er wartet auf die Ankunft des nächsten Pakets. Der Knoten arbeitet also nach dem
            Boss-Worker-Modell. Der Haupt-Thread, der das Nadelör des Knotens darstellt, soll also möglichst wenig
            Arbeit zu erledigen haben. Die Hauptarbeit wird von den Worker-Threads erledigt, damit die
            Paketbearbeitung parallel und somit möglichst schnell ablaufen kann.
        </p>
        <!--TODO: Boss-Worker Bildchen -->
        <p>
            Ein Worker-Thread bearbeitet das ihm übergebene Paket weiter. Je nach Typ des
            Pakets<span class="footnote">Siehe Aufgabenstellung</span> wird dabei unterschiedlich vorgegangen.
        </p>

        <h2>Verbindungen zu Nachbarn</h2>
        <p>
            Ein Netzwerk kann nur funktionieren, wenn die einzelnen Knoten miteinander kommunizieren können. Zu diesem
            Zweck unterhält jeder Knoten eine Liste mit all seinen Nachbaren. Nachbaren sind alle Knoten, deren
            IP-Adresse und TCP-Port bekannt ist und denen ein Paket direkt (d.h. ohne Umwege über andere Knoten)
            zugestellt werden kann. Erhält der Knoten ein Verbindungspaket, wird der im Paket codierte Nachbar zur
            Nachbarenliste hinzugefügt. Befindet sich dieser bereits in der Nachbarenliste, wird nichts unternommen.
        </p>
        <p>
            Verbindungen in diesem Netzwerk sind bidirektional. Das heisst, dass wenn A ein Nachbar von B ist, B
            ebenfalls ein Nachbar von A ist. Deshalb muss jeder Knoten beim Erhalt eines Verbindungspaketes
            sicherstellen, dass er beim gerade hinzugefügten Knoten auch als Nachbar hinzugefügt wird. Zu diesem Zweck
            ersetzt der Knoten zuerst die Nachricht im Paket mit seiner IP und seinem TCP-Port und schickt das Paket
            danach an seinen neuen Nachbarn. Diese Art der Verbindungsherstellung wird als
            <i>Handshake</i><span class="footnote">Englisch für Händeschütteln</span> bezeichnet.

            <!--TODO: Bildchen vom Handshake -->
        </p>
        <p>
            Um ein endloses Hin- und Hersenden von Verbindungspaketen zu verhindern, wird der Handshake nur durchgeführt,
            wenn sich der entsprechende Nachbar noch nicht in der Nachbarenliste befindet.
        </p>

        <h2>Routing</h2>
        <p>
            Der Router, beziehungsweise die Routingtabelle stellt eine Kernkomponente jedes Knotens dar. Hier wird
            gespeichert, an welchen Nachbarn ein Paket gesendet werden muss, wenn es den Ziel-, bzw. den Quellknoten
            erreichen will.
        </p>
        <p>
            Nach dem Start des Knotens ist die Routingtabelle zunächst leer. Mit dem Erhalten von Paketen, wird sie nach
            und nach ausgefüllt. Die Applikation nutzt dabei aus, dass Nachrichtenpakete immer entweder vom Quell-
            zum Zielknoten oder in die Gegenrichtung gesendet werden. Erhält ein Knoten also ein Paket, das für den
            Zielknoten bestimmt ist, kann er daraus schliessen, dass der Nachbar, von dem er das Paket erhalten hat, der
            Nachbar ist, der am nähesten am Quellknoten ist. Dieser Nachbarknoten wird deshalb in der Routingtabelle
            als Nachbar für Pakete eingetragen, die für den Quellknoten bestimmt sind. Der umgekehrte Fall gilt ebenso.
        </p>
        <table>
            <caption>Beispiel Routingtabelle</caption>
            <tr>
                <th>Ziel des Pakets</th>
                <th>Weiterleiten an Nachbar</th>
                <th>Bemerkung</th>
            </tr>
            <tr>
                <td>Quellknoten</td>
                <td>Localhost, 3336</td>
                <td>Pakete, die für den Quellknoten bestimt sind, werden an den lokalen Nachbarn auf Port 3336
                    weitergeleitet.</td>
            </tr>
            <tr>
                <td>Zielknoten</td>
                <td>0</td>
                <td>Eine 0 bedeutet, dass der entsprechende Nachbar noch nicht bekannt ist. In diesem Fall wird das
                    Netzwerk geflutet<span class="footnote">Siehe Kapitel <i>Packet-Forwarding</i></span>.</td>
            </tr>
        </table>
        <p>
            Die Routingtabelle überschreibt niemals Einträge, denn sonst könnte es passieren, dass bestehende Routen durch
            langsamere überschrieben werden. Das erste Paket, das einen Knoten erreicht, kam immer über die schnellste
            Route. Deshalb ist die erste eingetragene Route immer die schnellste.
        </p>
        <p>
            Dieses Vorgehen hat den Nachteil, dass bestehende Routen niemals gelöscht werden. Dies wäre zum Beispiel
            nötig, wenn ein bestimmter Knoten vom Netz genommen und die Route so ungültig werden würde. In dieser
            Applikation ist dies jedoch kein Problem, da die Aufgabenstellung nicht spezifiziert, dass Knoten vom Netz
            genommen werden können.
        <p>

        <h2>Packet-Forwarding</h2>
        <p>
            Erhält ein Knoten ein Nachrichtenpaket, ist es in den meisten Fällen nicht für ihn selbst bestimmt. In
            diesen Fällen muss der Knoten das Paket gemäss dem Paket-Ziel weiterleiten<span class="footnote">Englisch:
            To forward</span>. Dazu wird in der Routingtabelle nachgeschlagen, ob es für das entsprechende Ziel einen
            Eintrag gibt. Wenn ja, wird das Paket an den entsprechenden Nachbarn weitergeleitet. Falls der Nachbar nicht
            bekannt ist, bleibt dem Knoten nichts anderes übrig, als das Netzwerk mit Paketen zu fluten. Dabei wird das
            Paket an jeden bekannten Nachbarn geschickt, in der Hoffnung, dass sich darunter auch der richtige befindet.
        </p>
        <!--TODO: Bildchen mit Flooding -->
        <p>
            Falls das Netzwerk ringförmig verbundene Knoten hat, kann es passieren, dass das gleiche Paket nach dem
            Weiterleiten durch Knoten A ein weiteres Mal bei A ankommt. Dies ist der Fall, wenn A flutet und der
            letzte Knoten im Ring ebenfalls flutet - Dann schickt der letzte Knoten das Paket unter anderem wieder an A.
        </p>
        <!--TODO: Bildchen mit kreisförmiger Architektur -->
        <p>
            Dieser Mechanismus birgt die Gefahr, dass Pakete unendlich lange zwischen Knoten herumgeschickt werden. Dies
            wäre einerseits ineffizient und würde andererseits irgendwann zu einer Überlastung des Netzwerks führen.
            Deshalbt führt jeder Knoten eine schwarze Liste mit Paketen, die er bereits einmal weitergeleitet hat. Dazu
            wird die ID<span class="footnote">Siehe Aufgabenstellung</span> des Pakets verwendet. Erhält ein Knoten nun
            ein Paket, das bereits in seiner schwarzen Liste eingetragen ist, verwirft er es, anstatt es weiterzuleiten.
        </p>

        <h2>Erreichen des Ziels</h2>
        <p>
            Da Nachrichtenpakete immer in beide Richtungen geschickt werden können, kann die Endstation eines Pakets
            sowohl der Quell-, als auch der Zielknoten sein. Nach einer bestimmten Zeit wird jedes Nachrichtenpaket
            sein Ziel erreichen. Tritt dieser Fall ein, soll das Paket nicht mehr weitergeschickt werden. Allerdings
            wird aus dem Nachrichtenpaket ein OK-Paket mit gleicher ID<span class="footnote">Siehe
            Aufgabenstellung</span> erstellt und an den ursprünglichen Absender
            zurückgeschickt um diesen zu informieren, dass die Nachricht angekommen ist. Für das Funktionieren des
            Testprogramms muss zu diesem Zeitpunkt ausserdem der Inhalt der Nachricht in der Standardausgabe
            (<i>stdout</i>) ausgegeben werden.
        </p>
        <p>
            Beim Rückweg des Pakets als OK-Paket gestaltet sich das Routing sehr einfach, da optimale Route bereits
            bekannt bekannt ist: Jeder Knoten, der in der Route vorkommt, hat ja das ursprüngliche Paket schon einmal
            empfangen und hat deshalb einen entsprechenden Eintrag in der Routingtabelle. So weiss jeder Knoten sofort,
            an welchen Nachbarn er das Paket weiterleiten muss. Sollte sich aus unerfindlichen Gründen einmal kein
            Eintrag in der Routingtabelle finden, der dem Paket den Weg weist, wird wie gehabt das Netzwerk geflutet.
        </p>
        <p>
            Da ein OK-Paket die gleiche ID hat, wie das zu ihm gehörende Nachrichtenpaket, sind die IDs der OK-Pakete
            im Normalfall bereits in der schwarzen Liste erfasst. Damit die OK-Pakete den ursprünglichen Absender einer
            Nachricht trotzdem erreichen können, wird die schwarzse Liste beim Senden von OK-Paketen nicht beachtet.
        </p>
        <p>
            Sobald ein OK-Paket wieder beim ursprünglichen Absender der Nachricht angekommen ist, gibt dieser eine
            Erfolgsmeldung aus. Die Bearbeitung dieses Pakets ist somit für das Netzwerk beendet.
        </p>
    </div>

    <div class="chapter">
        <h1>Probleme und Lösungen</h1>
        <p>
            Da ein wichtigstes Resultat einer solchen Arbeit immer die daraus gezogenen Lehren sind, widmet sich dieses
            Kapitel den Problemen, auf die ich beim Umsetzen der Anwendung gestossen bin.
        </p>

        <h2>Concurrency-Problem</h2>
        <p>
            - Liste mit Nachbaren / Router / was noch?
            - mutexe verwenden
        </p>

        <h2>Problem, dass man nicht weiss, von wem das OK-Paket kommt</h2>
        <p>
            - Node, der z.B. auf Port 3334 läuft, macht fürs senden eines Packets eine neue Verbindung auf -> kann man also nicht benutzen
            - Lösung: Ans Ende der Nachricht wird immer noch der Absender-Port angehängt -> Paket wird deshalb nicht grösser,
              aber Kapazität der Nachricht wird auf 122 Byte verkleinert
        </p>

        <h2>Riesige Routing-Tabelle</h2>
        <p>
            - Modulo 255 rechnen
        </p>

        <h2>Segfaults</h2>
        <p>
            - GDB hat geholfen
        </p>
    </div>

    <div class="chapter">
        <h1>Ungelöste Probleme</h1>

        <h2>Ports bleiben manchmal besetzt</h2>
        <p>
            - Nach Laufen des Testprogramms (nicht immer, nicht reproduzierbar)
            - Testprogramm hat aber kein Interface, über das man ihm mitteilen kann, dass ein Port schon besetzt ist
            - Mögliche Lsg: Auf fixem port einen zentralen Node starten, der Aliase verwaltet
        </p>

        <h2>Ausgabe muss gepadded werden</h2>
        <p>
            - No Clue why, debugged for several hours
            - Solange Länge von Teststring nicht variiert, kein Problem :)
        </p>
    </div>

    <div class="chapter">
        <h1>Reflexion</h1>

        <h2>Soll- / Ist-Analyse</h2>
        <table>
            <caption>Soll- / Ist-Analyse</caption>
            <tr>
                <th>Soll</th>
                <th>Ist</th>
            </tr>
            <tr>
                <td>Ziel</td>
                <td>Erfüllt/Nicht erfüllt, siehe Kapitel xx</td>
            </tr>
        </table>
        <!--TODO: ein paar Worte dazu verlieren, welche Fälle getestet wurden und so-->

        <h2>Arbeitsprozess</h2>
        <p>
            placeholder
        </p>

        <h2>Persönliches Fazit</h2>
        <p>
            placeholder
        </p>

        <h2>Diverses</h2>
        <p>
            Die vorliegende Dokument wurde mit HTML, CSS und JavaScript erstellt und mit
            Prince<span class="footnote source">
                YesLogic Pty. Ltd. (2013), Prince<span class="additional">, Abgerufen am 01.06.2013 von
                http://www.princexml.com/</span></span> in ein PDF umgewandelt. Es ist im Originalformat verfügbar unter
            der URL <a href="https://github.com/elHornair/pictroid-doc"> https://github.com/elHornair/pictroid-doc</a>.
            Das Umsetzen der Projektdokumentation mit Webtechnologien stellte eine weitere lehrreiche Herausforderung dar.
        </p>
    </div>

    <div class="chapter">
        <h1>Verzeichnisse</h1>

        <h2>Glossar</h2>
        <p>
            Das Glossar ist alphabetisch geordnet.
        </p>

        <table>
            <caption>Glossar (alphabetisch geordnet)</caption>
            <tr>
                <th>Begriff</th>
                <th>Definition</th>
            </tr>
            <tr>
                <td>Placeholder Wort</td>
                <td>Placeholder Erklärung
                </td>
            </tr>
        </table>

        <h2>Abbildungsverzeichnis</h2>
        <ul id="fig_catalog" class="caption_catalog">
        </ul>

        <h2>Tabellenverzeichnis</h2>
        <ul id="table_catalog" class="caption_catalog">
        </ul>

        <h2>Quellenverzeichnis</h2>
        <ul id="source_catalog">
        </ul>

    </div>

    <div class="chapter">
        <h1>Anhänge</h1>

        <h2>Echtheitserklärung</h2>
        <p>
            Ich erkläre hiermit, dass ich die vorliegende Arbeit selbständig verfasst, alle wörtlichen und
            sinngemäßen Übernahmen als solche gekennzeichnet und keine anderen als die angegebenen
            Quellen benutzt habe.
        </p>
        <p>
            <br>
            <br>
            Alain Horner, 24. Juni 2013
        </p>
    </div>

</div>

</body>
</html>
